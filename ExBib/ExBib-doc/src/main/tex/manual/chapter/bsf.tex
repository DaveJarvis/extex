%%*****************************************************************************
%% $Id: bsf.tex,v 0.00 2008/09/07 09:30:45 gene Exp $
%%*****************************************************************************
%% Author: Gerd Neugebauer
%%-----------------------------------------------------------------------------

\section{Groovy as Style Language}

An experimental feature of \ExBib{} is the replanceemnt of the BST
language by some other language for writing styles. Here the Bean
Scripting Framework (BSF) is used as adapter for other languages. Any
language made available this way can be plugged in with minor effort
as style language.

As an example the language Groovy has been made available this way.


\subsection{Invoking the Groovy-enhanced \ExBib}

The property \Property{exbib.processor} determines which processor is
used. The value of this property must be set to th value \verb|groovy|
to activate the Groovy entension language. In the simplest case this
is done on the command line as shown in the following example:

\begin{lstlisting}[language=sh]
# exbib -Dexbib.processor=groovy myDocument.aux
\end{lstlisting}

If you want to activate this property for any invocation of \ExBib\ in
this directory then you can alternatively create a file named
\File{.exbib} in the current directory. This file should contain the
following line:

\begin{lstlisting}
exbib.processor=groovy
\end{lstlisting}

Then the usual invocation uses the Groovy extension instead of bst
style files:

\begin{lstlisting}[language=sh]
# exbib myDocument.aux
\end{lstlisting}

See also section \ref{sec:dot.files} for details.


\subsection{Specifying a Groovy Style}

A Groovy style file can be specified in the same way a bst style file
is given. In \LaTeX\ the command \Macro{bibliographystlye} writes the
name of the style file is written to the aux file. The name of the
style file is given without any extension -- like \verb|.gy| or
\verb|.groovy| for Groovy files.


\subsection{Accessing the Database in a Groovy Style}

The databases specified in the aux file are automaticaly read at
startup. The code contained in the Groovy style is executed after the
database has been read in. The database can be accessed via the global
variable \Var{bibDB}. This variable contains an object which
implements the interface \texttt{org.extex.exbib.core.db.DB}. The full
power of this Java interface is described in the Javadoc.


\subsection{The Output}

The global variable \Var{bibWriter} contains an instance of a class
implementing the interface \texttt{org.extex.exbib.core.io.Writer}.
This writer can be used to write to the output file.

It has a method \texttt{print} to print some strings:

\begin{lstlisting}[language=Java]
  bibWriter.print("{\em ", series, "\/}" )
\end{lstlisting}

It has a method \texttt{println} to print some strings followed by a
newline character:

\begin{lstlisting}[language=Java]
  bibWriter.println("\newcommand{\etalchar}[1]{$^{#1}$}" )
\end{lstlisting}


\subsection{The Processor Context}

The processor can be accesed through the global variable
\Var{bibProcessor}. This gives access to additional features like the
log file.


\subsection{Methods of the DB}

The important methods of the DB provide reading access to the stored
information. They are described below.

\newenvironment{methods}{\begin{description}\def\method##1{\item[##1]\ \\}%
}{\end{description}}

\begin{methods}
  \method{Entry getEntry(String key} %
    Get a single entry stored under the given reference key. The key
    is normalized before the entry is sought, i.e. the search is case
    insensitive.
    
    If no record is stored under the given key then <code>null</code>
    is returned.

  \method{String getExpandedMacro(String key)} %
    Compute the expanded representation of a macro. The expansion is
    performed by recursively replacing macro names by the definitions
    and concatenating the resulting list of values.
    
    For any macro which is not defined during the expansion the empty
    string is used instead.
    
    If the named macro the expansion is started with does not exist
    then \texttt{null} is returned.

  \method{Value getMacro(String name)}%
    Retrieve the definition of a macro.

  \method{int getMinCrossrefs()}%
    Getter for minCrossrefs.
    
    The parameter minCrossrefs determines when an entry which is
    referenced by several entries should be collated into the
    referencing entries. For example this can be the case for articles
    in a collection. Here the collection is shown as separate entry
    only if at least minCrossref entries in the result reference it.

  \method{Value getPreamble()}%
    Getter for the preamble.

  \method{Iterator<Entry> iterator()}%
    Get the iterator to iterate over the entries in the current order.

  \method{void setMinCrossrefs(int minCrossref)}%
    Setter for minCrossrefs.

  \method{void sort() throws ConfigurationException}%
    Sort the entries according to the configured sorter.
    Initially the entries are in the order in which they are read in.

\end{methods}

\subsection{Methods of the Entry}

\begin{methods}
  \method{Value get(String key, DB db) throws ExBibException}%
    Getter for the Value stored under a given key in the Entry. If the
    value is not found locally and the field crossref is present then
    the value is requested from the entry stored under the crossref key
    in the database.

  \method{String getExpandedValue(String key, DB db) throws ExBibException}%
    This method searches for a normal value and concatenates all
    expanded constituents. Macros are looked up in the database given and
    their values are inserted.

  \method{String getKey()}%
    Getter for the reference key for this Entry.

  \method{ValueItem getLocal(String key)}%
    Getter for a local value. The local values are stored independently from
    the normal values. This means that they have a name-space of their own.

  \method{Locator getLocator()}%
    Getter for the locator for this Entry. The locator allows you to
    determine where this Entry is coming from.

  \method{String getSortKey()}%
    Getter for the sort key of this Entry. The sort key is stored as local
    value under the key \texttt{sort.key\$}.

  \method{String getType()}%
    Getter for the type of this Entry.

  \method{Iterator<String> iterator()}%
    Getter for an iterator over all keys of normal values.

  \method{set(String key, String value)}%
    Setter for the Value stored under a given key in the Entry. The String
    valued parameter is wrapped into a  Value before it is stored.

  \method{void set(String key, Value value)}%
    Setter for the Value stored under a given key in the Entry. An already
    existing value is overwritten silently.

  \method{setKey(String string)}%
    Setter for the reference key for this Entry.

  \method{void setLocal(String key, int value)}%
     Setter for a local value. The local values are stored independently from
     the normal values. This means that they have a namespace of their own.

    This method wraps its int argument into a VNumber before it is stored.

  \method{void setLocal(String key, String value)}%
     Setter for a local value. The local values are stored independently from
     the normal values. This means that they have a namespace of their own.

     This method wraps its int argument into a VString before it is stored.

  \method{void setLocal(String key, ValueItem value)}%
    Setter for a local value. The local values are stored independently
    from the normal values. This means that they have a name-space of
    their own.

  \method{void setSortKey(String sortKey)}%
    Setter for the sort key of this Entry. The sort key is stored as
    local value under the key \texttt{sort.key\$}.

  \method{void setType(String t)}%
    Setter for the type of this Entry.

  \method{String toString()}%
\end{methods}

\subsection{Methods of the Value}

\begin{methods}
  \method{void add(Value item)}%
    Add all value items contained in a value to the current value.

  \method{void add(ValueItem item)}%
    Add a new value item to the end of the value.

  \method{String expand(DB db)}%
    Expand the whole value into a single String. All macros are replaced by
    their values and delimiting braces or quotes are omitted.

  \method{boolean isEmpty()}%
    Tests whether the value is empty.

  \method{Iterator<ValueItem> iterator()}%
    Getter for an Iterator for all elements.

\end{methods}


\subsection{Methods of the ValueItem}

\begin{methods}

  \method{void expand(StringBuilder sb, DB db)}%
    This method expands the ValueItem and appends the expansion to the given
    StringBuilder. Macros are looked up in the database given and their
    values are inserted.

  \method{String getContent()}%
    The getter for the content.

  \method{void setContent(String value)}%
    Setter for the content.

\end{methods}



\endinput%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Local Variables: 
% mode: latex
% TeX-master: "../exbib-manual"
% End: 
